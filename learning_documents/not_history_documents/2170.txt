C는1972년켄 톰슨과데니스 리치가 벨 연구소에서 일할 당시 새로 개발된유닉스운영 체제에서 사용하기 위해 개발한프로그래밍 언어이다. 켄 톰슨은 BCPL언어를 필요에 맞추어 개조해서 "B"언어(언어를 개발한 벨 연구소의 B를 따서)라 명명했고,데니스 리치가 이것을 개선하여 C언어가 탄생했다. 유닉스 시스템의 바탕 프로그램은 모두 C로 쓰여졌고, 많은 운영 체제의커널도 또한 C로 만들어졌다. 오늘날 많이 쓰이는C++는 C에서 객체 지향형 언어로 발전된 것이다. 또 다른 다양한 최신 언어들도 그 뿌리를 C에 두고 있다.C는 실질적으로 모든 컴퓨터 시스템에서 사용할 수 있는 프로그래밍 언어이다. 예를 들어 BASIC 등과는 달리 다양한플랫폼에서ANSI C의 정의에 따르는 비교적 동일한 구현이 가능하다. 모든 C 시스템에는 정규화된표준 C 라이브러리가 존재한다. 이런 이유와 생성된 프로그램의 높은 성능이 아직까지도 C언어가 사랑받는 이유 중 하나이다.그러나 C 언어가 기술적으로 보아 현재 기술 수준에 부합하지 않는다는 의견이 있으며, C를 "이식가능한 고급어셈블리어"정도로 낮추어 부르기도 한다. 이는 반면 오늘날의 널리 쓰이는 거의 모든 운영 체제커널이 C를 이용해 구현된 이유이기도 하다. C는시스템 프로그램개발에 매우 적합하나, 응용 프로그램 개발에도 많이 쓰인다.C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐AT&amp;T 벨 연구소에서 이루어 졌으며,[1]데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다. 언어의 이름이 "C"인 이유는 그 특징이 "B" 언어에서 유래되었기 때문이며,켄 톰슨에 의하면, B 언어는 BCPL 언어의 기본만 남긴 버전이다.리치와 톰슨에 의해 초기에PDP-7의 어셈블리 언어로 구현되었던유닉스운영체제의 개발과 C 언어의 기원은 밀접하게 연관되어 있다. 결국 그들은 유닉스 운영체제를PDP-11로 포팅하기로 결정하였다. PDP-11의 기능의 일부, 특히바이트접근기능을 활용하지 못하는 B 언어의 부족함이 C 언어의 초기 버전의 개발을 이끌었다.유닉스의 초기 PDP-11 버전은 어셈블리로 개발되었다. 1973년에struct자료형의 추가로, C 언어는 유닉스의 대부분을 C로 쓸 수 있을 정도로 강력해 졌다. 유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는PL/I로 쓰인Multics시스템,ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다. 존슨의Portable C Compiler는 새로운 플랫폼에서의 C의 구현의 기초가 되었다.[2]1978년에브라이언 커니핸과데니스 리치가The C Programming Language라는 책의 초판을 출간했다. 커니핸과 리치의 앞 글자만 따서 C 프로그래머들에게는 "K&amp;R"로 불리는 이 책은, 비공식적이지만 오랫동안 C의 규격과 같은 역할을 했다. 그리하여, 이 책에서 서술하는 C의 판이 "K&amp;R C"란 명칭으로 불리게 되었고, 이 책의 2판에서는 후의ANSI C표준을 다루게 되었다.K&amp;R에서 다음과 같은 기능이 등장한다.C 언어 표준이 상대적으로 정적으로 남아 있었던 동안,C++는 표준화를 위하여 계속 진화하고 있었다. 1995년에 1990년의 C 표준에 대한 규약 수정안 1이 출판되었는데, 이는 약간의 세부 사항을 교정하고 국제적 문자 세트에 대한 보다 확장된 지원을 위한 것이었다. C 표준은 1990년대 후반에 더 개정되어, 1999년 ISO/IEC 9899:1999가 출간되었고, 여기서 명시한 규범을 흔히C99라 부른다. 이는 기술적 교정에 의하여 현재까지 3번의 수정이 있었다. 국제 C 표준은 실무 그룹 ISO/IEC JTC1/SC22/WG14에 의해 관리되고 있다.2011년 ISO/IEC 9899:2011이 출간되었고, 간단하게C11라고 부른다.C11나오기 전까지 개발 버전을C1X라고 부른다. 최종 개발 버전은 2011년도 4월 N1570이였다.C는 C 표준에 의해 규정되는형식 문법을 갖고 있다.포트란 77과 같은 언어와 달리, C 소스코드는 free-form 언어로써 형식 코드에 공백을 마음대로 넣을 수 있다.OS에서 응용프로그램을 실행하거나, CPU의 프로그램을 실행하기 위해 여러가지 영역으로 나누어 메모리를 할당하고 이를 메모리에 올려 실행 한다.C언어로 개발된 프로그램은 메모리 입장에서 다음과 같은 할당 영역으로 나누어 생각할 수 있다.CPU을 사용하여 개발하여 장치에 넣어 코드를 실행할 때, 힙 영역을 많이 사용하지는 않는다. 따라서 필요 없다면 메모리 공간을 할당할 필요도 없고 힙관리 프로그램 코드(함수를 개발툴에서 라이브러리 형태로 제공)도 필요하지 않는다. 만약malloc등의 함수를 사용하면, 힙 영역을 사용하겠다는 의미 이기 때문에 힙 영역을 개발자가 선언하여 관리 해야 한다. 이 때 힙관리 프로그램 코드는 자동으로 링크 된다. 물론 저 사양의 CPU 경우, 이 함수를 제공하지 않을 수 있는 컴파일러도 있을 수 있다.C언어 작성된 코드는 컴파일 과정과 링크 과정을 거치면 실행 파일이 만들어진다. 변수는 여러가지 특성이 있다.이 프로그램 예에서 변수 별로 분리하면 다음과 같은 특성의 변수로 나눌 수 있다.char name[50] = "홍길동"[note 1];static char buff[1024];"전화 =&#160;%s\n""주소 =&#160;%s\n"char *pstr;int scount;char *piaddr;Notes:각 특성별로 나누어 그룹을 지어 메모리에 배치 하는데, 이것을 링커가 한다. 이렇게 그룹은 나누는 것을 세그먼트(SEGMENT) 또는 섹션(SECTION)이라는 단어를 사용 한다.위의 그룹은 가장 기본적인 내용만을 표시 한것이다. CPU와 컴파일 마다 다르다. 어떤 컴파일러는 더욱 세밀히 하기도 한다. 그리고 각 세그먼트 이름도 다르다.Visual Studio의 맵 이름 예컴파일 마다 각 세그먼트 이름과 구조가 다르지만, 예를 들어 중요한 세그먼트 만 표시 하였다, TEXT와 CONST는 ROM/FLASH에 배치 해도 되는 변하지 않는 세그먼트 이므로 같은 부류이고, CPU를 설계하고 코드를 직접 쓰는 경우 ROM/FLASH을 이용한다.거의 모든 툴에서 이 맵을 파일로 만들어 준다. 물론 옵션으로 설정을 해야하는 경우도 있지만 구조를 얻을 수 있다. 함수와 변수의 위치와 이름 등을 확인할 수 있고, 각각의 세그먼트 크기 등의 데이터를 알 수 있다. 실제 CPU을 다루는 C언어에서 이런 정보는 중요하다. 내가 사용하는 MCU의 메모리는 얼마나 사용하는지 등을 확인할 필요가 있기 때문이다.C언어 함수는 표준함수가 있고, 개발 툴에서 제공하는 함수가 있다. 여러가지 부류가 있고 특성 별로 나누어 lib 파일로 코드를 제공하고 헤더파일로 선언을 알 수 있다.C 표준 라이브러리는 함수 형태와 기능이 정해져 있기 때문에 개발툴별 같다는 특징이 있다.유닉스 계열(리눅스)의 시스템에서 주로 사용하는 C/C++ 언어 개발 도구이다. 리눅스의 OS을 제 컴파일하거나, 각종 응용프로그램 개발에 사용한다. 또한 X-Windows의 개발 도구로도 사용 할 수 있다.전자 장치의 개발 시 임베디드 OS 포팅에서, 리눅스 커널이나 리눅스 커널 기반으로 하는 OS 커널 자체를 개발하는 도구로 사용 한다. 리눅스 커널 기반 임베디드에서 실행되는 응용 프로그램 역시gcc을 많이 사용 한다.여러 파일들끼리의 의존성과 각 파일에 필요한 명령을 정의함으로써 프로그램을 컴파일할 수 있으며 최종 프로그램을 만들 수 있는 과정을 서술할 수 있는 표준적인 문법을 가지고 있고, 구조로 기술된 파일(주로 Makefile이라는 파일명)을 [[make]가 해석하여 프로그램 빌드를 수행하게 된다.gcc을윈도에서 실행 할 수 있도록 재 포팅한 것이다.Cygwin에서 분화 된 gcc 기반 개발 라이브러리 이다.이클립스는 다양한 언어와 다양한OS에서 실행 되는IDE이다. 따라서 여러가지 상황에서 다양하게 적용할 수 있다.C/C++언어를 제공하는IDE으로 리눅스의 경우 기존의gcc을 사용할 수 있도록 연결 설정만 하면 된다.윈도에서gcc와 연결하여 C/C++ 언어를 사용하여 프로그램을 개발 할 수 있다. MinGW는 다양한 언어를 지원하므로 다른 언어로도 이클립스와 연결하여 개발 도구로 사용할 수 있다.비주얼 프로그래밍은 크게 윈도 프로그램과 윈도가 아닌 프로그램으로 나누어 생각할 수 있다. 초기의 마이크로소프트의 개발 도구는 C언어로 부터 출발 하였다. 오브젝트 프로그램의 필요성이 대두되면서 C++가 추가 되었다.윈도 프로그램은 초기에 Win32 SDK을 기반으로 하였다. 오브젝트의 개념없이 함수를 사용하여 윈도 프로그램을 작성 한다. 후에 C++로 가면서MFC로 진화 하였다.C/C++의 라이브러리를 이용하여 윈도 없이 실행되는 프로그램을 말 한다. 비주얼 프로그램에서는 C와 C++가 통합 되어 있으므로C 표준 라이브러리뿐만 아니라STL등도 사용할 수 있다.SDK(Software Development Kit)라는 말은 일반적인 소프트웨어 개발 도구를 나타내는 말이지만 마이크로소프트의 윈도 개발에서는 클래스화 되지 않는 C 라이브러리를 윈도 SDK라고 부르기도 했다. 윈도 개발 도구를 만들 초기에 붙인 이름이다.이것은 Visual Studio에 통합되어 C 언어의 라이브러리 형태로 개발할 수 있다.윈도 개발에 필요한 각종 윈도 요소를 클래스화 하였다. Win32 SDK도 같이 사용할 수 있다.윈도에서 주로 게임 등을 개발할 때 사용하는 툴킷 이다. 고속의 화면 제어, 음성지원, 3D 등을 지원한다.보통 소프트웨어 개발에서 디버깅의 가장 일반적인 방법은 두가지 이다.GCC을 기반으로 하는디버깅도구이다. 따라서유닉스계열에서 가장 일반적으로 실행된다.GCC 옵션을 디버깅이 되도록 설정하면 디버깅 테이블을 만든다. gdb 실행 중에 이것을 사용한다. GDB을 실행하여 응용프로그램을 실행하면서 break, 변수, 함수 등의 디버깅을 할 수 있다.GCC에서gdb는 서버 구조를 사용할 수 있다.gdb-server을 설치하면네트워크를 통해 더버깅 환경을 구성할 수 있다. 예를 들어 임베디드 개발 시 리눅스 커널을 포팅하고, 해당 리눅스 시스템에 gdb-server를 설치하면 다른 환경에서 이를 통해 응용프로그램을 디버깅 할 수 있다. 임베디드의 많은 경우 자신의 시스템에서는 디버깅이 만만치 않다. 따라서 원격으로 gdb의 실행 결과를 전송 할 수 있고 이 정보를 바탕으로 이클립스와 같은 IDE와 연동할 수 있다. 보통 리눅스 기반의 임베디드 개발 환경은 이클립스 C++를 사용할 수 있는데, 이것과 결합할 수 있다.원격 디버깅 모드는 리눅스 커널에 사용되는 소스 수준의 디버거인 KGDB에서도 사용된다. KGDB를 사용하면 커널 개발자는 일반 응용 프로그램과 마찬가지로 커널을 디버깅할 수 있다.비주얼 스튜디오나이클립스등의 도구 들은 기본적으로 디버깅 방법을 제시 한다. 이클립스 디버깅은GDB와 연동해서 구성할 수 있다.이 프로그램은 표준 콘솔 출력으로hello, world를 출력한다.