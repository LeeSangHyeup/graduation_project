포인터는 데이터의 위치를 나타내기 위한 변수이다. 데이터의 위치라는 말은 프로그램 측면에서 보면 변수의 위치를 말하는 것이다.프로세서가 동작하기 위해서는 코드와 변수의 값들을 처리하기 위한 메모리 공간이 필요하고 결국 변수는 메모리의 특정 영역을 점유하여 결정된다. CPU입장에서 보면 메모리는 주소값으로 지정 한다. 메모리 종류에 따라 const 변수를 제외한 변수는RAM형(SRAM,DRAM)의 메모리에 존재 한다. 그리고 CPU을 설계하고 동작 시키는 경우는 보통ROM/FLASH에 존재 할 수 있다. 이것은 컴퓨터의 동작 상태에 따라 결정된다. 개인용 컴퓨터의 롬바이어스는 보통 FLASH에 프로그램 기계어 코드가 들어간다. 프로그램이 동작 할 때는 변하는 값을 취급할 때, 주 메모리 DRAM에 잡을 것이다. 윈도나 리눅스의 응용프로그램은 모두 RAM에 코드를 올리고 실행하기 때문에 변수 및 코드가 RAM에서 실행된다. 어찌 되었건 메모리는 CPU 입장에서는 이진수의 주소값일 뿐이다. 결국 메모리의 변수 영역은 CPU의 주소값으로 지정되고 실행된다. 이런 기본적인 개념에서 포인터는 주소값으로 모든 메모리의 주소 위치를 지정할 수 있다. 따라서 포인터라는 말은 CPU 입장에서 보는 메모리의 주소값이라는 간단한 원리만 생각하면 이해가 쉽다.그러면 프로그램의 변수나 코드의 메모리의 주소는 누가 결정하는가를 생각하면,링커에 의해 위치가 결정된다. 링커에 의해 결정되면 프로그램이 실행 될 때, 주소값을 가지고 데이터를 읽거나 쓰는 처리를 함으로써 우리가 원하는 프로그램이 실행된다.포인터 변수 모두는 메모리의 주소를 지정하는 값을 가지고 있으면 값을 변화시킬 수 있기 때문에 CPU을 설계한 설계 기준에 따라 주소값의 길이와 방식이 결정된다. 일반적인 용도의 대부분의 CPU는 메모리를 지정하는 길이(비트수)는 동일하다. RAM이든 ROM/FLASH 이든 모든 주소는 같다. MCU(8051,...)은 오히려 많은 경우 메모리 영역을 나누어 다른 주소체계를 사용 한다. 8051은 내부의 256바이트 내에 변수를 할당 한다. 256바이트는 매우 적기 때문에 많은 데이터 저장용으로 16비트의 저장 공간을 갖는 주소체계를 사용하고 기계어 코드를 분리 했다. 이럴 경우는 주소값이 8비트 또는 16비트가 필요하다.C언어가 UNIX 계열의OS작성 할 때 사용하였으므로 커널의 프로그램 소스를 보면 상당히 많은 부분 포인터 변수를 볼 수 있다.포인터 변수는 *을 이용하여 선언 한다. 포인터는 메모리의 주소값을 가지고 데이터의 위치를 지정하기 때문에 다른 변수의 저장 공간의 주소를 알아야 한다. 따라서 정적 변수의 주소는 &amp; 연산자를 사용 한다.ival는 정수형 데이터가 들어가는 변수이다. 즉, 정수 숫자를 저장 한다. 그러나 변수 pval은 데이터 공간의 위치를 지정하는 것이지 정수형 데이터를 저장하는 것은 아니다. CPU의 주소체계에서 메모리의 주소값을 저장 함으로써 데이터가 저장 될 주소값을 가지고 액세스 하는 것이다. 그러나 메모리 주소값도 하나의 이진수의 정수형의 일종이라고 생각 할 수 있다.포인터 변수는 다른 정적 변수나 동적변수(malloc(), new)에 의해 존재하는 저장 공간을 지정하는 변수이다. 그러나경우에 데이터 저장공간을 지정하지 못하고 액세스 할 수 있다. 보통 저장공간 지정은 했는지 하지 않았는지는 NULL을 이용할 수 있다.NULL 사용 예:C/C++에서 NULL은 숫자 0으로 정의 되어 있다. 자료구조 등에서도 '없다'는 의미로 null을 사용하는데, 경우에 따라 정해진 비트수 만큼 이진수로 모두 1인 경우가 있다. 그러나 C/C++에서는 0으로 정의 되어 있으므로 메모리의 0번지에는 특수하게 사용하지 않는다.만약 포인터 변수가 데이터 저장공간을 지정하지 않았다면 NULL을 사용하여 초기화 시키는 방식이 일반적이다.포인터 변수의 길이(변수의 비트수)는마이크로프로세서에 의존 한다. 즉, 마이크로프로세서가 주소 공간과 액세스 체계를 이미 가지고 있기 때문에 C/C++언어의 컴파일러는 이를 따를 뿐이다. 즉, 포인터 변수의 길이는 CPU 의존적으로 결정 되어 있으므로 모든 포인터의 길이는 같다. 그렇다면 왜 포인터 변수 선언 시, 앞에 변수형이 필요한가는 액세스 할 때 데이터 액세스 길이(비트수)를 결정하기 위해서 이다.32비트 CPU의 대부분은 32비트 주소공간과 32비트 데이터 액세스 단위를 가지므로 다음 예는 32비트라고 가정 하면:코드 중*pval = 10;은 pval가 void형이므로 액세스 시, 10을 어떻게 규정할지 결정할 수가 없다. 보통 10은 정수형으로 취급 되지만 같은 정수형도 8,16,32비트로 다르다. 따라서 pval의 변수형에 따라서 비트수가 결정되는데 여기서는 void이므로 결정 불가능 하다.이 프로그램 예에서 실제스트링메모리 공간을 갖는 것은 name, tel, bstr 변수 들이다. 그러나 pstr변수는 스트링 데이터가 들어갈 변수가 아니고 데이터가 들어가야할 위치를 지정하는 변수이다. CPU의 주소체계에 의한 주소값으로 데이터의 위치를 지정하는 것이다. 이 포인터 변수는 메모리 주소값만 가지면 되므로 정해진 길이의 비트수를 가지고 동작 한다.포인터 변수가 갖는 메모리의 주소값은 결국 정수형의 2진수 숫자 일 뿐이다. 따라서 CPU내의 ALU을 통해 연산 된다.일반적인 32비트 CPU의 주소체계는 주로 32비트 메모리 주소값을 사용 한다. 따라서 CPU의 주소값을 정수형으로 보고 값의 치환, 비교, 연산 등이 가능하다.pval++에서 연산자 ++는 포인터의 주소값을 다음 위치로 하나 더 옮기라는 뜻이다. 보통의 정수형 변수라면 1을 더하는 것이겠지만 이런경우 주소값을 한 칸 더 옮기는 경우이다. 따라서 단순히 1을 더하는 것이 아니고 포인터 변수가 갖는 int형의 크기만큼 더해진다.pval++에서 ++ 연산자&#160;:예를 들어 현재 &amp;ival[0] == pval == 0x00301200 이라면&#160;:즉, ival의 인덱스가 0에서 1로 옮겨 간다.psstr++ 경우, 예를 들어 현재 psstr == 0x00301200 이라면&#160;:이 때는 char 변수가 한 바이트 단위로 배열 되기 때문에 주소값이 1씩 ALU에 의해 더해 진다.실행결과&#160;:이 경우의 pman+cnt에서cnt = 1일 때, 포인터의 값을 다음과 같이 계산할 수 있다:포인터 변수는 결국 메모리의 변수 위치의 주소값을 다루는 변수이다.따라서 CPU에 따라 길이가 결정된다. CPU에 메모리 주소체계가 컴파일러 보다 우선 설계되기 때문에 해당 CPU에 맞추어 포인터 컴파일러 설계를 한다. 주로 8비트 CPU의 16비트의 주소값을 갖는다. 그러나 8비트 중에MCU계열은 주소를 지정하기 위한 비트가 다양하다. 8비트와 16비트가 혼재하기도 한다. 같은 CPU라도 8비트와 16비트를 같이 사용한다는 이야기 이다.CPU의 프로그램에서 CPU의 메모리 체계을 이해 해야 만 포인터 변수의 길이를 알 수 있다.이에 비해 32비트는 주로 32비트의 주소 비트 수를 갖는다. 거의 모든 CPU가 32비트 이므로 오히려 8비트 CPU 보다 길이가 통일 되어 있다. 64비트로 가면 또 다른 비트 수를 갖을 것이다.각각의 변수가 들어갈 메모리의 위치와 성격에 따라 메모리를 지정하는 주소값의 비트수는 CPU에 의해 결정 되어 있으므로 어떤 컴파일이든 정해져 있다.변수의 길이를 알아보는 방법의 예&#160;:일반적인 포인터 변수의 길이는x86의 실행결과 값 예