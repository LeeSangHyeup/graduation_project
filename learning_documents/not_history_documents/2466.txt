RSA는공개키 암호시스템의 하나로, 암호화뿐만 아니라전자서명이 가능한 최초의알고리즘으로 알려져 있다. RSA가 갖는전자서명기능은 인증을 요구하는전자 상거래등에 RSA의 광범위한 활용을 가능하게 하였다.1977년로널드 라이베스트(Ron Rivest),아디 샤미르(Adi Shamir),레오널드 애들먼(Leonard Adleman)의 연구에 의해 체계화되었으며, RSA라는 이름은 이들 3명의 이름 앞글자를 딴 것이다. 이 세 발명자는 이 공로로 2002년튜링상을 수상했다.RSA 암호체계의 안정성은 큰 숫자를소인수분해하는 것이 어렵다는 것에 기반을 두고 있다. 그러므로 큰 수의 소인수분해를 획기적으로 빠르게 할 수 있는 알고리즘이 발견된다면 이 암호 체계는 가치가 떨어질 것이다.1993년피터 쇼어는쇼어 알고리즘을 발표하여,양자 컴퓨터를 이용하여 임의의 정수를다항 시간안에 소인수분해하는 방법을 발표하였다. 따라서 양자 컴퓨터가 본격적으로 실용화되면 RSA 알고리즘은 무용지물이 될 것이다. 그러나 양자 컴퓨터가 이 정도 수준으로 실용화되려면 아직 여러 해가 더 필요할 것으로 보인다.RSA 암호화 알고리즘은1983년에 발명자들이 소속되어 있던매사추세츠 공과대학교(MIT)에 의해미국에특허로 등록되었고,2000년9월 21일에 그 특허가 만료되었다.RSA는 두 개의키를 사용한다. 여기서 키란 메시지를 열고 잠그는 상수(constant)를 의미한다. 일반적으로 많은 공개키 알고리즘의공개키(public key)는 모두에게 알려져 있으며 메시지를 암호화(encrypt)하는데 쓰이며, 암호화된 메시지는개인키(private key)를 가진 자만이 복호화(decrypt)하여 열어볼 수 있다. 하지만 RSA 공개키 알고리즘은 이러한 제약조건이 없다. 즉 개인키로 암호화하여 공개키로 복호화할 수 있다.공개키 알고리즘은 누구나 어떤 메시지를 암호화할 수 있지만, 그것을 해독하여 열람할 수 있는 사람은 개인키를 지닌 단 한 사람만이 존재한다는 점에서 대칭키 알고리즘과 차이를 가진다.RSA는 소인수분해의 난해함에 기반하여, 공개키만을 가지고는 개인키를 쉽게 짐작할 수 없도록 디자인되어 있다.보다 이해하기 쉬운 예를 들자면, A라는 사람에게 B라는 사람이 메시지를 전하고자 할 때 B는 A의 열린 자물쇠를 들고 와 그의 메시지를 봉인(공개키 암호화 과정에 해당)하고, 그런 다음 A에게 전해 주면, 자물쇠의 열쇠(개인키에 해당)를 가지고 있는 A가 그 메시지를 열어보는(개인키 복호화 과정에 해당) 식이 된다. 중간에 그 메시지를 가로채는 사람은 그 열쇠를 가지고 있지 않으므로 메시지를 열람할 수 없다.메시지와 공개키 모두를 알 수 있다면 변조된 메시지를 보낼 수 있기 때문에, 실제로는 수신측의 공개키만을 사용하여 암호화하는 경우는 드물다. 송수신 양측의 키쌍을 사용하는 방법으로는 A의 개인키로 암호화 -&gt; B의 공개키로 암호화 한 메시지를 전달하고 복호화 과정은 B의 개인키로 복호화 -&gt; A의 공개키로 복호화로 구성된 방식이 일반적이다. RSA의 디자인 상, 그 열쇠(개인키에 해당)는 자물쇠의 형태(공개키에 해당)만 보고서는 쉽게 제작할 수가 없게 되어 있다.A와 B가 보안이 보장되어 있지 않은 환경에서 서로 비밀 메시지를 주고 받고 싶다고 가정하자. B가 A에게 메시지를 전달하기 위해서는 A의 공개키가 필요하다. A는 아래와 같은 방법을 통해 그만의 공개키와 개인키를 제작한다.A의 공개키는 위에서 구한 두 개의 숫자로 이루어진 &lt;N,e&gt;이고, 개인키는 &lt;N,d&gt;이다. A는 &lt;N,e&gt;만을 B에게 공개하고, B는 이 공개키를 사용하여 자신의 메시지를 암호화하게 된다. 여기서p와q의 보안은 매우 중요하다. 이를 가지고d와e의 계산이 가능하기 때문이다. 그리하여 공개키와 개인키가 생성이 된 후에는 이 두 숫자를 지워버리는 것이 안전하다.B가M이란 메시지를 A에게 보내고 싶다고 하자. 일단 B는 이M를N보다 작은 숫자로 변환한다. (이 변환법(padding scheme)은 A에게도 미리 알려져 있어야 한다. 이를테면, 메시지를 토막내어 하나의 메시지가 일정 수의 비트를 넘지 않게 하는 방법이 있다. 하지만 실제로는 이중보안을 위해 더욱 복잡한 변환법이 사용된다.) 그리고 B는 A의 공개키 &lt;N,e&gt;를 획득하고, 다음과 같이c를 계산한다.그리고 이c를 A에게 보낸다.A는 암호화된 메시지c를 B에게서 건네받았고,N과d를 알고 있다. 다음 식을 통해m을 찾는다.위에서 설명하였듯m을 가지고 A는M을 찾아낼 수 있는 방법을 알고 있다.이 해독법이 가능한 이유는 다음과 같다.마지막 등식이 성립하는 이유는 다음과 같다. 위의 식에서mod N대신mod p사용하여 풀이했을 때,가 된다.p가 소수이므로, m이 p의 배수가 아니라면 서로소이므로페르마의 소정리를 다음 식과 같이 적용할 수 있다. 만약 m이 p의 배수라면 양변이 p의 배수이므로 0과 동치가 되어 역시 다음 식이 성립된다.mod q를 사용하여도 똑같은 풀이가 가능하다.N=pq이므로,mod N에도 같은 식이 성립하게 된다.아래는 작은 수를 이용해 암호화 방식을 예로 든 것이다.공개 키와 비밀 키 생성 과정은 다음과 같다.예를 들어 평문는 다음과 같이 암호화된다암호문은 다음과 같이 복호화된다실제 구현에서는중국인의 나머지 정리를 이용해 암호화 및 복호화 과정을 빠르게 수행할 수 있다.,and를 사전에 계산해 둔다.위 값이 미리 계산되어 있으면, 다음과 같이 암호화와 복호화 과정을 수행한다.위의 예제는 단어 'zfxlb'를 가지고 구한 것이다.