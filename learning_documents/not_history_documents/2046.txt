C++는AT&amp;T벨 연구소의비야네 스트롭스트룹이1983년발표하여 발전한 프로그래밍 언어이다.C 언어의 문법을 대부분 사용할 수 있으며, 객체지향성이 더해진 C 언어의 확장형이라고 생각할 수도 있다. 원래 이름은C with Classes였으나,증가 연산자를 도입하면서 1984년에 C++로 이름이 변경되었다.[1]C 언어에 객체지향 프로그래밍을 지원하기 위한 내용이 덧붙여진 것이라고 할 수도 있지만, 애초부터 객체지향을 염두에 두고 만들어진 언어와는 다르게, 단지 더 좋은 C 언어로서 수속형 언어로 취급하기도 한다. 초기의 C++은 C 위에 놓인 트랜스레이터로 구현되었다. 즉, C++ 프로그램을 일단 C 프로그램으로 변환하고 나서 C 컴파일러로 컴파일하는 식이었고 따라서 C 언어에 대해 상위 호환성을 갖는 언어였다.그 후, C 언어의 표준 규격이 바뀔 때 const 수식 등 C++의 기능이 C 언어에 받아들이기도 했다. 현재 C 언어와 C++와의 사이에는 엄격한 호환성은 없다. 특히C99의 출현으로 C 언어와의 호환성은 완전하게 없어져 버렸다. 현재는 C와 C++가 명확한 구별 없이 혼재되어 사용되는 컴파일러가 대부분이다.다음과 같은 다양한 기능을 가지고 있어 C++ 언어의 표준 규격은 몹시 복잡하다. C++ 표준의 모든 사항을 완전하게 지원하는 컴파일러는 현재 손꼽을 정도이다.덧붙여 예부터 전해 내려온 절차적인 성격도 그대로 남아 "만능" 설계로, 유연함과 강력함은 다른 언어에 비할 바가 아니지만, 복잡한 언어가 되고 말았다. 이런 점 때문에 보다 객체지향성을 강화하여,만능설계를 지향하기보다는 단순한 설계를 목표로 한 새로운 언어들인Java언어,D 언어등이 나오기도 했다.캡슐화는 2가지 요소를 만족하도록 언어적으로 구현 되어야 한다.C++에서는 객체의 저장공간의 위치(this로 표현되는 객체의 데이터 위치 주소값)를 함수에 넘김으로써 데이터와 메서드를 결합한다. this는 객체의 위치 주소값인 포인터 이다.객체 지향 프로그래밍에서 작성된 프로그램 코드는 재 사용이 중요한 요소이다. 재 사용하려면 다른 개발자가 사용할 때, 필요한 사용방법만 알면된다. 클래스 내면 깊숙히 알 필요가 없는 경우가 많다. 따라서 객체를 설계할 때, 경우에 따라멤버 변수나멤버 함수를 다 알릴 필요가 없다. 어떤 요소들은 내부에서 사용하고 비공개로 설정할 필요가 있다. 해당 객체를 사용하거나 상속해서 사용할 때, 필요한 요소만을 공개하고 API을 작성하여 공개하면 된다. 이런 비공개의 방법으로 은닉을 설정하고 캡슐화의 한요소가 된다.키워드 3개가 있다. private, protected, public을 사용해서 접근을 제한할 수 있다.여기서 데이터와 메서드 결합은 멤버함수를 구성할 때 this라는 포인터로 상징되는 것을 개발자 코드내에 코딩없이도 자동으로 넘겨 주어 해당 클래스 내의 멤버변수들을 사용하게 하였다. 이렇게 언어적으로 결합한다.this는 자동으로 객체의 공간위치값이 메모리의 주소값이다. 이것을 포인터로 사용하였다. 이것으로 결국 어떤 객체인지를 구별하는 수단으로 사용하여, 데이터와 메서드를 결합한다.MyObject::가 붙는 클래스의 멤버함수는 실행할 때 자동으로 모두 this가 넘어간다. static 메서드는 this가 제외된다.this가 멤버 함수에 넘어가는 방법으로 CPU의 레지스터를 사용할 수도 있다. 멤버 함수에서 멤버 변수를 사용할 때 레지스터에 저장된 객체의 위치 주소값으로 하여 내부 멤버변수의 상대주소값과 합하여 위치값을 다시 설정하고 액세스 하면 된다. 이것은 마치 struct의 시작주소와 내부변수의 상대적 위치값의 합으로 표현하는 주소체계와 유사하다.C++ 표준 라이브러리스트림 기능을 사용하여표준 출력을 통해Hello, world!를 출력한다.객체를 구현하기 위해클래스의 선언이 필요하다. 구조적인 설정을 하고 생성하면 된다.객체의 모양은클래스를 사용하여 형을 선언하여 프로그램 한다. C언어에서 전역변수, 지역변수가 있듯이 객체도 선언 위치에 따라 생성과 소멸이 다르다.객체 만들기&#160;:객체 소멸&#160;:클래스는캡슐화가 가능하다. 따라서 객체를 설계할 때는 특정 멤버변수나 멤버함수를 외부에서 접근을 제한할 필요가 있다.접근 제어 키워드 3가지:C언어에서 전역변수와 지역변수 그리고 동적할당에 의한 데이터 저장공간을 만들 수 있다. C++에서도 함수 밖에 객체를 잡을수도 있고 함수 내에 잡을 수 있다. new을 통해 동적으로로 객체를 생성 시킬 수 있다.C++에서 변수를 잡듯이 객체도 선언을 통해 이루어 진다. C에서 전역변수와 지역변수로 나누어는 것과 같이, 객체 역시 같은 방식으로 전역 또는 지역 객체로 선언할 수 있다.전역 정적 객체는 main() 함수가 실행 되기 전 저장공간이 생성되고, 생성자가 호출된다. 객체가 생성되면 메모리에 데이터 저장공간이 생기고 바로 생성자가 호출된다. 따라서 전역 정적 객체 생성자의 호출은 main함수보다 먼저 이루어진다.new에 의해 생성 되고, delete에 의해 삭제 된다. new로 생성 되면, new 실행 시점에서 객체의 저장공간인 메모리를 확보하고 생성자가 자동실행 된다. 동적객체는 힙영역에 존재하고 포인터를 넘겨 받아서 객체 포인터 변수에 주소값을 저장하고 처리한다.'new'의 코딩은 함수에 넣을 수 밖에 없으므로 main 함수 시작 이후에야 가능하다.C/C++은 포인터를 사용한다. 이것은 객체의 크기만 확보되면 객체를 사용하는데 아무 문제가 없다. 따라서 이미 설정된 변수를 포인터를 이용하여 객체화 해서 사용할 수 있다.실행결과:모든 함수는 블럭을 포함하므로 함수내에서 생성된 정적객체는 함수의 블럭이 끝나면 소멸자가 호출되고 객체의 저장공간은 사라진다. 위의 예처럼 임의의 블럭에서 생성된 정적객체 역시 자기의 블럭이 끝나면 소멸자가 호출되고 사라진다.클래스 내에서 멤버변수로 다른 클래스를 사용할 수 있다. 정적 멤버변수와 포인터가 가능하다. 그러나 2개의 클래스가 서로 정적인 객체를 선언하면 교착상태로 빠져 객체의 크기를 결정할 수 없다. 따라서 불가능해 진다.클래스 내에서 클래스 변수 선언 시 교착상태실행결과 예:객체는 클래스에 의해 규정된 구조에 따라 메모리 공간을 확보하고 메모리에액세스함으로써 데이터 처리가 된다. 이 구조는 기본적으로 struct와 별로 다를 바가 없다. 멤버변수만을 모아 순서데로 나열하여 특정 크기의 메모리를 확보하면 된다. struct에 C++에 필요한 몇가지 추가될 수 있다.위의 예 프로그램의 객체구조를 알기 위해 다음과 같이 프로그램 하면:실행결과 (x86, 32비트) 예&#160;:소멸자에서virtual을 붙이는 가장 중요한 이유는 상속과 관련하여 소멸자를 정확히 실행하기 위해서 이다. 소멸자를 호출할 때, 이 테이블을 보고 호출한다.'static int MyObject::counter' 변수는 객체와 분리하여 한개의 전역변수로 처리된다. 따라서 이것은 객체의 메모리 크기에 들어가지 않는다.sizeof연산자에 의해 바이트수를 얻은면 16바이트가 된다. 여러개의 같은 클래스의 객체가 존재해도 이 변수는 하나만 존재할 뿐이다. 그리고 정적으로 처리되므로 전역변수만 가능하다.이제virtual을 삭제하고 객체를 만들면 멤버변수들로만 구성된 구조를 갖는다.실행결과 (x86, 32비트) 예&#160;:이것은 다음struct와 메모리 구조가 같다.실행결과 (x86, 32비트) 예&#160;:클래스 내부의 변수를 말 한다. 클래스의 속성(attribute) 이다. 기본 자료형과 다른 클래스 들도 정의가 가능하다.멤버함수는 프로그램 코드이므로 결국 기계어 코드 묶음에 존재한다. 멤버함수가 실행될 때, 객체의 변수들로 구성된 메모리 구조체의 시작 주소값으로 전달되어 조작된다.C에서도 마찬가지 이지만, C++는 단지 메모리의 주소값을 이용하여 액세스하는 단순한 방법을 사용한다. 따라서 배열등에서 정의된 크기보다 큰 인덱스로 쓰기하면, 쓰기 자체에는 아무 문제없이 써진다. 그러나 변수가 차지하고 있는 공간을 넘어서는 문제는 C++에서도 그대로 적용된다. 자바와는 달리 어떤 보호책이 없다.실행 결과 예 (x86 32비트 CPU, 마이크로소프트 비주얼스튜디오):[note 1]여기에서 10이어야 하는 값이 252579084로 바뀌어 졌다. 이것은 16바이트를 쓰면서 buff영역을 넘어서기 때문이다. buff와 객체 a와는의 공간차이가 난다. 따라서 12바이트 이상 쓰기 하면 a 영역의 값이 변한다.Notes:클래스의 행위(behavior)를 정의한 것으로 기능적으로 설정된 프로그램 묶음이다.모든 멤버함수는 멤버변수들로 구성된 구조적 저장공간이 필요하다. 각각의 다른 객체는 다른 메모리 공간에 존재 한다. 따라서 여러개의 객체를 구별한 포인터 변수가 필요하다. this는 객체의 위치를 정의하는 포인터 변수라고 생각하면 된다.어느 객체에 조작을 할것인가를 결정하는 포인터 이다. 'this'는 클래스 내에 변수 선언이 필요없고 이미 정의된 키워드 이다.캡슐화의 방법으로 멤버함수는 this을 통해 멤버변수와 묶는 방법으로 사용한다.다음 예의 구조체와 클래스에서위의 예에서 C언어의 struct는 구조체 내의 변수들을 묶어서 메모리에 할당한다.위의 2개의 차이는 'MyObject::'을 붙이면 this 포인터가 자동으로 들어간다. 이를 통해 멤버함수를 클래스와 통합한다. 그러나 C언어의 함수는 어떤 변수의 구조체와 연결이 없다. 필요하면 포인터나 변수를 인수를 통해 넘길 뿐이다. 그러나 C++에서는 this는 반드시 포함 시키는 차이가 있다. static 멤버함수는 this가 넘어가는 것은 제외된다.this가 객체의 위치 주소값을 취급하는 자동 포인터로써 멤버함수가 호출되면 자동으로 따라 다닌다. 이말은 이미 객체가 존재 한다는 것이다. 그러나 static을 사용하면 특정 객체의 this을 사용하지 않는다. 객체가 이미 존재하는 것은 상관없이 이미 존재하는 객체의 포인터 값을 모른다. 따라서 호출 할때, 특정 객체가 미리 생성되지 않아도 된다. 이미 생성 되었다면 오히려 인수로 넘겨 주어야 한다.위의 프로그램 예제 코드 처럼, 객체가 없는 상태에서 실행되는 것이 static 멤버함수이기 때문에 객체의 멤버변수를 사용하지 않아도 된다. 클래스 이름으로 호출하면 되고 설령 이미 존재하는 객체의 멤버변수로 하더라고 this 가 넘어가지 않으므로 별 차이가 없다.캡슐화되지 않는 C 언어의 함수와 별 차이가 없다. C 언어의 함수와의 차이는 단지 '어느 클래스에 속하는냐'만의 의미만 갖는다.비야네 스트롭스트룹저, 곽용재 역,C++ 프로그래밍 언어,ISBN 9788945072047