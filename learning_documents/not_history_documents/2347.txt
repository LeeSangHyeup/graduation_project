러스트(영어:Rust)는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다. "안전하고, 병렬적이며, 실용적인" 언어로 디자인되었으며,[1]순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍,명령형 프로그래밍,객체 지향 프로그래밍스타일을 지원한다.2006년 개발자 그레이든 호아레의 개인 프로젝트로 시작되었으며, 2009년 호아레의 고용주인 모질라가 개발에 참여했다.[2]2010년 처음으로 일반에 공개되었으며,[3]같은 해Objective Caml로 작성된 초기 컴파일러에서 Rust로 쓰여진 컴파일러로 전환되었다.[4]rustc는 2011년 처음으로 자기 자신을 컴파일하는데 성공했다.2012년 1월 첫 번째 알파 버전인 0.1이 발표되었다.[5]현재 최신 버전은 2014년 1월에 발표된 0.9 버전이다.모질라의 정책[6]에 따라, Rust는 전적으로 오픈 소스로 개발되고 있으며, 커뮤니티로부터 피드백을 받고 있다. 모질라 재단과삼성전자가 Rust의 개발을 후원하고 있다. Rust의 설계에는 모질라의 렌더링 엔진인 Servo와 rustc 컴파일러를 개발하면서 쌓인 경험들이 반영되어 있다.Rust는인터넷에서 실행되는 서버 및 클라이언트 프로그램을 개발하는데 적합한 언어를 목표로 설계되었다. 이 목표에 따라 Rust는 안전성과병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다. 또한 성능 면에서는C++와 비슷한 수준을 목표로 하고 있다.Rust의 문법은 중괄호로 코드 블록을 구분하고,if,else,while등의 키워드를 사용하는 등C및C++와 유사한 모양을 하고 있다. 그러나 Rust와 C/C++는 의미상으로는 크게 다른 문법을 갖고 있다.Rust는 메모리 에러를 발생시키지 않도록 설계되었다. Rust는 널 포인터나 초기화되지 않은 포인터가 존재하지 않도록 강제하고 있다. 모든 변수는 초기값을 가지고 할당되며, 해제된 포인터에 접근하는 코드는 컴파일러가 미리 감지하여 컴파일 에러를 일으킨다.타입 시스템은하스켈의 영향을 받아 타입 클래스를 지원한다. 또한, 변수 선언 시 타입을 지정하지 않아도 컴파일러가 타입 추론을 통해 해당 변수의 타입을 지정할 수 있다. 반면 함수의 인자나 반환값에서는 타입 정보를 빼놓을 수 없다.병행 프로그래밍은얼랭과 유사한 actor 기반의 모델을 사용하고 있다. 각각의 태스크는 데이터를 직접 공유하지 않고 메시지 전달을 통해서만 데이터를 교환할 수 있다. 메시지를 복사할 때 생기는 성능 저하를 막기 위해, unique box의 경우 데이터 복사 없이 메시지를 전달할 수 있다. unique box는 하나의 객체만이 소유할 수 있고, 다른 태스크로 전달될 경우 데이터 복사 없이 소유권만 바뀌게 된다.객체 시스템은 implementation, trait, struct 또는 enum으로 이루어져 있다.struct또는enum은 객체의 데이터를 정의하는데 사용되며,impl키워드로 정의하는 implementation은 객체의 멤버 함수를 정의하는데 사용된다. 객체의 상속은trait을 통해 이루어지며,C++의 다형 상속 문제를 회피하기 위해 trait은 객체의 멤버를 정의할 수 없도록 만들어져 있다.아래 코드는 Rust 0.6 기준이며, Rust의 문법은 향후 바뀔 수 있다.Hello world:아래는 각각재귀함수와 반복문을 사용해 작성된계승함수이다:다음은 Rust의 병행 프로그래밍 기능을 보여주는 예제이다Rust 0.4 이전 버전은, 정적 타입 검사에 더해 타입 상태 분석 기능을 지원하였다. 타입 상태 분석 기능은 선언문 전후에check키워드를 사용하여 해당 선언문이 의도대로 동작하는지 컴파일시에 검사할 수 있었다. 그러나 이 기능은 실질적으로 거의 사용되지 않아 제거되었다.객체 시스템은 Rust 0.2에서 0.4에 거쳐 많은 변화를 겪었다. Rust 0.2는 처음으로 클래스를 도입하였고, 0.3에는 소멸자와 인터페이스가 도입되었다. 그러나 0.4에 trait 기능이 도입되면서 인터페이스는 trait와 통합되었고, class는 제거되었다.