nesC(networkembeddedsystems C)는컴포넌트 기반,이벤트 처리 기반프로그래밍 언어로,TinyOS플랫폼의 응용 프로그램을 작성하기 위해 사용된다. TinyOS는무선 센서 네트워크에 사용되는임베디드장비들을 구동시키도록 디자인된운영 환경이다. nesC는C언어의 확장으로, TinyOS에서 응용 프로그램을 실행하기 위해 컴포넌트들을 서로 "결합"하도록 되어 있는데, 이 "결합"하는 것을 "Wiring", 결합된 것을 "Wired"라고 표현한다.nesC의 기본적인 개념은 다음과 같다.1.Separation of construction and composition: programs are built out of components, which are assembled ("wired") to form whole programs. Components have internal concurrency in the form of tasks. Threads of control may pass into a component through its interfaces. These threads are rooted either in a task or a hardware interrupt. 1. 구축과 구성의 분리&#160;: 프로그램들은 프로그램을 구성하기 위하여 "결합된(Wired)" 컴포넌트들로 이루어져 있다.2.Specification of component behaviour in terms of set of interfaces. Interfaces may be provided or used by components. The provided interfaces are intended to represent the functionality that the component provides to its user, the used interfaces represent the functionality the component needs to perform its job.3.Interfaces are bidirectional: they specify a set of functions to be implemented by the interface's provider (commands) and a set to be implemented by the interface's user (events). This allows a single interface to represent a complex interaction between components (e.g., registration of interest in some event, followed by a callback when that event happens). This is critical because all lengthy commands in TinyOS (e.g. send packet) are non-blocking; their completion is signaled through an event (send done). By specifying interfaces, a component cannot call the send command unless it provides an implementation of the sendDone event. Typically commands call downwards, i.e., from application components to those closer to the hardware, while events call upwards. Certain primitive events are bound to hardware interrupts.4.Components are statically linked to each other via their interfaces. This increases runtime efficiency, encourages robust design, and allows for better static analysis of programs.5.nesC is designed under the expectation that code will be generated by whole-program compilers. This should also allow for better code generation and analysis.