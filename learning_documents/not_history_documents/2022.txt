C 프로그래밍 언어에서 변수는 숫자의 표현에 관련해서 정수형과 실수형이 있다. 이것의 처리는마이크로프로세서의ALU와 연관되어 처리 한다. 그리고 자료가 있는 위치값인메모리주소값으로 처리하는포인터변수가 있다. 이것은 CPU의 메모리 체계와 관련되어 있어 CPU 의존적이다. 그리고 관련된 정보 끼리 묶어 처리하는struct구조체 변수가 있다.정수형의 표현은char,int로 선언을 한다. char는 8비트로 규정되어 있어 변수의 범위가 결정되지만 int는 CPU와OS에 의존적이라 변수의 크기를 조정하는short와long을 사용 한다. 그리고 음수와 양수를 규정하기 위해signed와unsigned가 있다. unsigned을 이용하여 양수 정수 만을 취급할 수 있다.실수를 처리하기 위해 float와 double을 사용한다. 실수를 2진수를 표현할 때는부동소수점(Float-Point) 방식을 사용한다. 이것은 국제표준IEEE 754규격에 따른다.포인터 변수 모두는 메모리의 주소를 지정하는 값을 가지고 있으면 값을 변화시킬 수 있기 때문에 CPU을 설계한 설계 기준에 따라 주소값의 길이와 방식이 결정된다. 일반적인 용도의 대부분의 CPU는 메모리를 지정하는 길이(비트수)는 동일하다. RAM이든 ROM/FLASH 이든 모든 주소는 같다. MCU(8051,...)은 오히려 많은 경우 메모리 영역을 나누어 다른 주소체계를 사용 한다. 8051은 내부의 256바이트 내에 변수를 할당 한다. 256바이트는 매우 적기 때문에 많은 데이터 저장용으로 16비트의 저장 공간을 갖는 주소체계를 사용하고 기계어 코드를 분리 했다. 이럴 경우는 주소값이 8비트 또는 16비트가 필요하다.C언어가 UNIX 계열의OS작성 할 때 사용하였으므로 커널의 프로그램 소스를 보면 상당히 많은 부분 포인터 변수를 볼 수 있다.포인터 변수는 *을 이용하여 선언 한다. 포인터는 메모리의 주소값을 가지고 데이터의 위치를 지정하기 때문에 다른 변수의 저장 공간의 주소를 알아야 한다. 따라서 정적 변수의 주소는 &amp; 연산자를 사용 한다.ival는 정수형 데이터가 들어가는 변수이다. 즉, 정수 숫자를 저장 한다. 그러나 변수 pval은 데이터 공간의 위치를 지정하는 것이지 정수형 데이터를 저장하는 것은 아니다. CPU의 주소체계에서 메모리의 주소값을 저장 함으로써 데이터가 저장 될 주소값을 가지고 액세스 하는 것이다. 그러나 메모리 주소값도 하나의 이진수의 정수형의 일종이라고 생각 할 수 있다.포인터 변수는 다른 정적 변수나 동적변수(malloc(), new)에 의해 존재하는 저장 공간을 지정하는 변수이다. 그러나경우에 데이터 저장공간을 지정하지 못하고 액세스 할 수 있다. 보통 저장공간 지정은 했는지 하지 않았는지는 NULL을 이용할 수 있다.NULL 사용 예:C/C++에서 NULL은 숫자 0으로 정의 되어 있다. 자료구조 등에서도 '없다'는 의미로 null을 사용하는데, 경우에 따라 정해진 비트수 만큼 이진수로 모두 1인 경우가 있다. 그러나 C/C++에서는 0으로 정의 되어 있으므로 메모리의 0번지에는 특수하게 사용하지 않는다.만약 포인터 변수가 데이터 저장공간을 지정하지 않았다면 NULL을 사용하여 초기화 시키는 방식이 일반적이다.포인터 변수의 길이(변수의 비트수)는마이크로프로세서에 의존 한다. 즉, 마이크로프로세서가 주소 공간과 액세스 체계를 이미 가지고 있기 때문에 C/C++언어의 컴파일러는 이를 따를 뿐이다. 즉, 포인터 변수의 길이는 CPU 의존적으로 결정 되어 있으므로 모든 포인터의 길이는 같다. 그렇다면 왜 포인터 변수 선언 시, 앞에 변수형이 필요한가는 액세스 할 때 데이터 액세스 길이(비트수)를 결정하기 위해서 이다.32비트 CPU의 대부분은 32비트 주소공간과 32비트 데이터 액세스 단위를 가지므로 다음 예는 32비트라고 가정 하면:코드 중*pval = 10;은 pval가 void형이므로 액세스 시, 10을 어떻게 규정할지 결정할 수가 없다. 보통 10은 정수형으로 취급 되지만 같은 정수형도 8,16,32비트로 다르다. 따라서 pval의 변수형에 따라서 비트수가 결정되는데 여기서는 void이므로 결정 불가능 하다.이 프로그램 예에서 실제스트링메모리 공간을 갖는 것은 name, tel, bstr 변수 들이다. 그러나 pstr변수는 스트링 데이터가 들어갈 변수가 아니고 데이터가 들어가야할 위치를 지정하는 변수이다. CPU의 주소체계에 의한 주소값으로 데이터의 위치를 지정하는 것이다. 이 포인터 변수는 메모리 주소값만 가지면 되므로 정해진 길이의 비트수를 가지고 동작 한다.포인터 변수는 데이터 저장 위치 주소값을 사용하는 변수이다. 보통 정적 변수의 경우 직접액세스 모드(direct access mode)의 기계어 코드로 컴파일 된다.포인터 변수의 예&#160;:변수 자체의 길이는 CPU의 메모리 체계에 의해 결정된다. 32비트 CPU는 거의 다 32비트의 메모리 주소값을 갖는다. 따라서 위의 모든 변수의 크기는 4바이트이다.앞에 변수형이 필요한 이유는 액세스 할 때, 몇 비트의 단위로 액세스 하는냐를 결정한다. void의 경우는 데이터가 몇 비트인지 결정할 수 없으므로 결국 액세스형 변환을 통해 몇비트 액세스 인지 결정 해야한다.void 포인터 변수의 예&#160;:위*pvdata = 10;에서 10이라는 숫자는 기본적으로 정수형인데, pvdata의 액세스 단위가 결정되지 않았다. 즉, 이런경우 액세스 단위는 변수가 결정 한다. 따라서 이런 경우는 오류로 나타난다.포인터 변수가 갖는 메모리의 주소값은 결국 정수형의 2진수 숫자 일 뿐이다. 따라서 CPU내의 ALU을 통해 연산 된다.일반적인 32비트 CPU의 주소체계는 주로 32비트 메모리 주소값을 사용 한다. 따라서 CPU의 주소값을 정수형으로 보고 값의 치환, 비교, 연산 등이 가능하다.pval++에서 연산자 ++는 포인터의 주소값을 다음 위치로 하나 더 옮기라는 뜻이다. 보통의 정수형 변수라면 1을 더하는 것이겠지만 이런경우 주소값을 한 칸 더 옮기는 경우이다. 따라서 단순히 1을 더하는 것이 아니고 포인터 변수가 갖는 int형의 크기만큼 더해진다.pval++에서 ++ 연산자&#160;:예를 들어 현재 &amp;ival[0] == pval == 0x00301200 이라면&#160;:즉, ival의 인덱스가 0에서 1로 옮겨 간다.psstr++ 경우, 예를 들어 현재 psstr == 0x00301200 이라면&#160;:이 때는 char 변수가 한 바이트 단위로 배열 되기 때문에 주소값이 1씩 ALU에 의해 더해 진다.실행결과&#160;:이 경우의 pman+cnt에서cnt = 1일 때, 포인터의 값을 다음과 같이 계산할 수 있다:포인터 변수는 결국 메모리의 변수 위치의 주소값을 다루는 변수이다.따라서 CPU에 따라 길이가 결정된다. CPU에 메모리 주소체계가 컴파일러 보다 우선 설계되기 때문에 해당 CPU에 맞추어 포인터 컴파일러 설계를 한다. 주로 8비트 CPU의 16비트의 주소값을 갖는다. 그러나 8비트 중에MCU계열은 주소를 지정하기 위한 비트가 다양하다. 8비트와 16비트가 혼재하기도 한다. 같은 CPU라도 8비트와 16비트를 같이 사용한다는 이야기 이다.CPU의 프로그램에서 CPU의 메모리 체계을 이해 해야 만 포인터 변수의 길이를 알 수 있다.이에 비해 32비트는 주로 32비트의 주소 비트 수를 갖는다. 거의 모든 CPU가 32비트 이므로 오히려 8비트 CPU 보다 길이가 통일 되어 있다. 64비트로 가면 또 다른 비트 수를 갖을 것이다.각각의 변수가 들어갈 메모리의 위치와 성격에 따라 메모리를 지정하는 주소값의 비트수는 CPU에 의해 결정 되어 있으므로 어떤 컴파일이든 정해져 있다.변수의 길이를 알아보는 방법의 예&#160;:일반적인 포인터 변수의 길이는x86의 실행결과 값 예&#160;:함수 역시 기계어 코드가 특정 메모리를 점유하고 이것을 읽어 실행 하는 것이다. 따라서 코드의 위치를 주소값으로 표현할 수 있다.함수의 위치 정보를 가지고 호출하는 방식으로 실행 시킬 수 있다. 이 변수의 선언은 괄호를 이용한다.함수의 예&#160;:함수 포인터를 사용할 때는 위와 같이 인수까지 정의를 해야 한다. 초기와는 달리 현재의 표준화 된 C/C++언어에서는 인수가 달라지면 다른 함수가 되기 때문이다.그러나 다음과 같이 함수 포인터 변수와 인수가 맞지 않으면 문제가 발생 한다. fun과 cadd함수는 인수가 다르다. 컴파일 오류가 발생 한다.인수가 달라서 오류가 발생하는 예&#160;:결국 함수 포인터 변수는 인수까지 정의가 되어야 한다.배열 역시 가능하다.배열 함수 포인터 사용 예:실행결과 값 예&#160;: