하버드 아키텍처(Harvard architecture)는 본래 명령용 버스와 데이터용 버스로 물리적으로 분할한컴퓨터 아키텍처를 나타내는 용어이다. (폰 노이만 구조와 대비시킨 용어이기도 하다).이 말은하버드 마크 I(Harvard Mark I) 라는 릴레이 컴퓨터로부터 나온 것으로 이 머신은 명령을천공 테이프에 메모리해 데이터를릴레이의 ON/OFF 상태로 메모리했다. 이러한 초기의 머신에서는 메모리 영역이 지극히 작았기 때문에CPU내부에 모든 메모리 영역이 포함되어 있어 명령 메모리 영역을 데이터로서 취급할 수가 없었다(프로그래밍은 완전히 오프 라인의 작업이며, 프로그램의 내용을 컴퓨터 자신이 참조하거나 갱신하거나 하는 데에 이득이 없었다.).폰 노이만 구조에서는CPU는 메모리로부터 명령을 읽고, 메모리로부터 데이터를 읽고 쓰기도 한다. 명령과 데이터는 같은 신호 버스와 메모리를 사용하기 때문에 이러한 액세스하는 경우 동시에 발생할 수가 없다. 하버드 아키텍처의 컴퓨터에서는 명령을 메모리로부터 읽는 것과 데이터를 메모리로부터 읽는 것을 동시에 할 수 있다. 하버드 아키텍처의 컴퓨터는 명령의 처리를 끝내자마자 다음의 명령을 읽어들일 수 있기 때문에 보다 더 빠른 속도를 낼 수 있다고 말할 수 있다. 그렇지만 이러한 처리 속도를 높이려면 보다 많은 전기 회로가 필요하다.최근에 CPU의 성능은 메모리의 속도와 비교해 크게 향상했다. 성능을 높이려면 주 메모리의 접근 횟수를 줄이는 노력이 필요하다. 명령을 처리할 때마다 주 메모리에 접근할 필요가 있다고 한다면 성능 향상은 전망할 수 없다. 이른바메모리 속박 문제이다.메모리는 속도가 올라가면 값이 비싸질 수 있다. 이를 해결하는 방법은캐시로 불리는 작은 규모의 고속의 메모리를 준비하는 것이다.CPU는 필요로 하는 메모리의 내용이 캐시에 존재하면 성능이 향상된다. 하지만 반대로 필요한 메모리의 내용이 캐시에 없으면, 메모리로부터 캐시에 내용을 가져오는 것이다. 이 캐시의 조정이 컴퓨터의 설계로 중요한 관점이 되고 있다.최신의 성능이 좋은 CPU 설계에서는 하버드와 폰 노이만 두 쪽 모두의 아키텍처를 도입하고 있다. 캐시 메모리 장치는 보통 명령용과 데이터용으로 분리되어 있다. 하버드 아키텍처는 CPU와 캐시의 관계에 활용되고 있다. 캐시에 오류가 일어나면 주 메모리로부터 데이터를 가져 오고, 명령 캐시나 데이터 캐시에 저장한다. 따라서, 폰 노이만 구조는 CPU 외부에 적용된다.하버드 아키텍처는 특수한 디지털 신호 처리 프로세스에서 자주 쓰인다. 이를테면,아날로그 디바이스의블랙핀프로세서는 하버드 아키텍처를 활용하고 있다.또한 범용 마이크로 콘트롤러의 상당수는 하버드 아키텍처에 기반을 두고 있다. 마이크로칩 테크놀로지사의 PIC 마이크로 콘트롤러, ATMEL사의 AVR 마이크로 컨트롤러 등이 그 예이다. 이러한 프로세서는 프로그램과 데이터를 저장하는 작은 메모리를 내장하고 있는 것이 특징이다. 그리고 또 다른 이점으로는 프로그램 메모리와 데이터 메모리가 분리되어 있으므로 각자 다른 비트수를 사용할 수 있다는 것이다. 즉 AVR 프로세서의 경우 명령어는 대부분 16비트 1워드로 구성되어 있는데 비해 데이터는 모두 8비트로 처리한다. 그 때문에RISC와 하버드 아키텍처를 활용해 1 머신 사이클로 1 명령을 실행할 수 있게 되는 것이다.하버드 아키텍처는 이러한 장점이 있는 대신 단점도 존재한다. 프로그램 중에 데이터가 함께 혼합된 경우, 예를 들어 폰트 데이터나 표시할 문장 데이터, 메뉴 데이터 등은 프로그램과 함께 존재해야 하는데, 프로세서가 이러한 데이터를 읽어들이려고 시도하면 엄연히 '데이터'를 읽으려 하므로 데이터 메모리에서 이 내용을 찾으려 한다. 그런데 이 데이터들은 프로그램 메모리에 존재하기 때문에 프로그램 메모리로부터 데이터를 읽을 수 있는 특수 상황의 명령어가 필요하고, 더구나 프로그램 메모리와 데이터 메모리의 비트수가 다른 경우 주소를 변환하는 과정을 거쳐야 한다.[1]범용 마이크로 프로세서로 캐시 메모리 장치를 명령 캐시와 데이터 캐시를 분리했을 경우에 보다 성능이 좋은 write back형의 캐시를 사용하면 문제가 발생한다. write back형에는 캐시에 있는 내용을 CPU로 고쳐 썼을 경우에 그것을 주메모리에 동시에 써 되돌리지 말고 그대로 보관 유지해 두는 방식이다. 한편, 주 메모리도 동시에 고쳐 쓰는 캐시를 write through형 캐시라고 말한다. write back형 캐시는 그 캐시 라인을 다른 캐시 라인으로 옮겨놓을 때 주 메모리에 써 되돌리는지 CPU는 명시적으로 캐시 플래시를 지시했을 때에 주 메모리에 전체를 써 되돌린다.특정 용도가 아닌 컴퓨터에서는컴파일러를 사용하고 실행 파일을 만든다. 이때 실행 파일을 메모리 맵 파일로 하고 있으면, 명령 줄이 데이터 캐시에 남게 된다. 그러므로 컴파일한 뒤 바로 실행하면 명령 줄이 주 메모리에 써 되돌려지지 않은 경우에 실행이 실패할 가능성이 있다. 인터프리터와 컴파일러가 일체화하고 있는 일부의 고급 언어나 어떤 종류의 개발 환경을 제공하는 소프트웨어에서는 한층 더 현저하게 발생한다. 이러한 경우 컴파일 결과는 그 소프트웨어의 데이터 영역에 있고 있어 그 영역에 트리키인 수법으로 점프하는 것으로 실행하려고 한다. 이 또한 명령 줄이 메모리에 써 되돌려지지 않기 때문에 실행이 실패하는 일이 있다.이것은 일부분 하버드 아키텍처에 일어나는 문제며, 본질적으로는폰 노이만 구조이기 때문에 발생하는 문제이다.